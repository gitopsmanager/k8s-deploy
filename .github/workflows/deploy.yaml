# deploy.yaml
# Copyright (c) 2025 Affinity7 Consulting Ltd
# Version: v2 (reusable, minimal auth precedence)
# SPDX-License-Identifier: MIT

on:
  workflow_call:
    inputs:
      github_runner:
        required: true
        type: string
      namespace:
        required: true
        type: string
      target_environment:
        description: >
          The environment to deploy to (e.g., `dev`, `qa`, `prod`).

          - If the environment maps to a **single cluster** in `env_map`, this is all you need.
          - If the environment maps to **multiple clusters**, you must also set `target_cluster`.
        required: true
        default: "dev"
        type: string

      # REQUIRED when env has >1 clusters
      target_cluster:
        description: >
          The specific cluster to deploy to when the selected target_environment
          has more than one cluster in `env_map`.

          - For single-cluster environments (like `dev`, `qa`), leave this empty.
          - For multi-cluster environments (like `prod` with both `aks-prod-weu` and `aks-prod-use`),
            you must provide one of the valid cluster names from `env_map`.

          Example: `aks-prod-weu`   
        required: false
        default: ""
        type: string
      ref:
        description: "The github ref to use for checking out files"
        required: false
        type: string
        default: ${{ github.ref || github.sha }}
      delete_first:
        description: "Delete the namespaced app first before deploying it."
        required: false
        type: boolean        
      delete_only:
        description: "Delete ArgoCD app(s) without redeploying"
        required: false
        type: boolean
        default: false
      cd_repo:
        required: true
        type: string
      cd_repo_org:
        required: true
        type: string
      github_environment:
        required: false
        type: string
      # Mode A (single app)
      application:
        required: false
        type: string
      deploy_path:
        description: "The repo path to the deployment files"
        required: false
        type: string
        default: Deployments
      image_tag:
        required: false
        type: string
      image_base_name:
        required: false
        type: string
      image_base_names:
        required: false
        type: string
      overlay_dir:
        required: true
        type: string
        default: ""

      # Mode B (multi app)
      application_details:
        description: >-
          JSON array where each item maps:
          { "name" => application, "images" => image_base_names[], "path" => deploy_path }
          Example:
          [
            {"name":"app1","images":["repo/app1","repo/sidecar"],"path":"services/app1"},
            {"name":"app2","images":["repo/app2"],"path":"apps/app2"}
          ]
        required: false
        type: string
        default: ''

      # Environment map (single supported shape)
      env_map:
        description: >-
          ONLY this JSON shape is supported:
          {
            "<env>": {
              "cluster_count": N,
              "clusters": [
                { "cluster": "...", "dns_zone": "...", "container_registry": "...", "uami_map": [...] }
              ]
            }
          }
        required: false
        type: string

      # Argo / misc
      argocd_auth_token:
        required: false
        type: string
      argocd_username:
        required: false
        type: string
      argocd_password:
        required: false
        type: string
      kustomize_version:
        required: false
        type: string
        default: "5.0.1"
      skip_status_check:
        required: false
        default: false
        type: boolean
      insecure_argo:
        required: false
        default: false
        type: boolean
      debug:
        required: false
        type: boolean
        default: false
    secrets:
      CONTINUOUS_DEPLOYMENT_GH_APP_ID:
        required: true
      CONTINUOUS_DEPLOYMENT_GH_APP_PRIVATE_KEY:
        required: true
      ARGOCD_CA_CERT:
        required: false
      ARGOCD_USERNAME:
        required: false
      ARGOCD_PASSWORD:
        required: false

jobs:
  deploy:
    name: >-
      ${{ inputs.target_environment }}${{ inputs.target_cluster != '' && format(' - {0}', inputs.target_cluster) || '' }}
    runs-on: ${{ inputs.github_runner }}
    environment: ${{ inputs.github_environment }}
    outputs:
      cd_path: ${{ steps.env.outputs.cd_root }}
    steps:
    - name: Checkout repo
      if: ${{ inputs.delete_only == false }}
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        repository: ${{ github.repository }}
        path: source
        ref: ${{ inputs.ref }}


    - name: Report usage metrics (non-blocking)
      uses: actions/github-script@v7
      continue-on-error: true
      timeout-minutes: 0.5
      env:
        USAGE_ENDPOINT: https://gitopsmanager.io/github-action-metrics
      with:
        script: |
          const fetch = global.fetch;
          const endpoint = process.env.USAGE_ENDPOINT;
          if (!endpoint) {
            core.warning('‚ùå USAGE_ENDPOINT is not defined');
            return;
          }

          const repoFull = process.env.GITHUB_REPOSITORY || "";
          const [org, repo] = repoFull.split("/");

          const payload = {
            org,
            repo,
            action: "deploy", // or "build" etc.
            timestamp: new Date().toISOString(),
          };

          core.info(`üìä Sending metrics: ${JSON.stringify(payload)}`);

          try {
            const resp = await fetch(endpoint, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });

            const text = await resp.text(); // read raw body once

            if (resp.ok) {
              core.info(`‚úÖ Usage metrics reported successfully (${resp.status}).`);
              core.info(`üîç Response body: ${text}`);
            } else {
              core.warning(`‚ö†Ô∏è Metrics report failed: HTTP ${resp.status}`);
              core.warning(`Response body: ${text}`);
            }
          } catch (err) {
            core.warning(`‚ùå Metrics request threw: ${err.message}`);
          }



    - name: Generate GitHub App token
      id: generate_token
      uses: actions/create-github-app-token@v2
      with:
        app-id: ${{ secrets.CONTINUOUS_DEPLOYMENT_GH_APP_ID }}
        private-key: ${{ secrets.CONTINUOUS_DEPLOYMENT_GH_APP_PRIVATE_KEY }}
        owner: ${{ inputs.cd_repo_org }}
        repositories: ${{ inputs.cd_repo }}



    - name: Checkout reusable workflow repo
      if: ${{ inputs.delete_only == false }}
      uses: actions/checkout@v4
      with:
        repository: gitopsmanager/k8s-deploy
        ref: v2.1
        path: reusable

    - name: Checkout continuous-deployment repo
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.cd_repo_org }}/${{ inputs.cd_repo }}
        token: ${{ steps.generate_token.outputs.token }}
        path: continuous-deployment

    - name: Detect cloud
      id: cloud
      if: ${{ inputs.delete_only == false }}
      uses: gitopsmanager/detect-cloud@v1
      with:
        timeout-ms: 800


    - name: Warn if GitHub-hosted (unknown cloud)
      if: ${{ steps.cloud.outputs.provider == 'unknown' && inputs.delete_only == false  }}
      run: |
        echo "‚ö†Ô∏è Running on a GitHub-hosted runner."
        echo "Workload Identity mappings for AWS/Azure self-hosted runners will not apply."

    - name: Import ENV_MAP from runner
      shell: bash
      run: |
        printf "ENV_MAP<<EOF\n%s\nEOF\n" "$ENV_MAP" >> $GITHUB_ENV



    - name: Load Environment Config
      id: env
      uses: gitopsmanager/k8s-load-env@v1
      env:
        ENV_MAP: ${{ env.ENV_MAP }} 
      with:
        env_map: ${{ inputs.env_map }} 
        target_environment: ${{ inputs.target_environment }}
        target_cluster: ${{ inputs.target_cluster }}
        namespace:  ${{ inputs.namespace }}






    # Unify to a single apps[] list for either mode
    - name: Resolve apps (single or multi)
      id: apps
      uses: actions/github-script@v7
      env:
        APP_DETAILS: ${{ inputs.application_details }}
        APPLICATION: ${{ inputs.application }}
        DEPLOY_PATH: ${{ inputs.deploy_path }}
        IMG_ONE: ${{ inputs.image_base_name }}
        IMG_LIST: ${{ inputs.image_base_names }}
      with:
        script: |
          const detailsRaw = (process.env.APP_DETAILS || '').trim();
          let apps = [];

          if (detailsRaw) {
            let arr;
            try { arr = JSON.parse(detailsRaw); }
            catch (e) { core.setFailed(`‚ùå application_details is not valid JSON: ${e.message}`); return; }

            // Normalize to array if single object
            if (!Array.isArray(arr)) {
              core.info('application_details is a single object ‚Üí wrapping in an array');
              arr = [arr];
            }

            for (let i = 0; i < arr.length; i++) {
              const it = arr[i] || {};
              const name = String(it.name || '').trim();
              const path = String(it.path || '').trim();
              const images = Array.isArray(it.images) ? it.images.map(String) : [];

              if (!name) { core.setFailed(`‚ùå application_details[${i}].name is required`); return; }
              if (!path) { core.setFailed(`‚ùå application_details[${i}].path is required`); return; }

              apps.push({ name, path, images });
            }
          } else {
            // Single app mode (inputs)
            const name = (process.env.APPLICATION || '').trim();
            const path = (process.env.DEPLOY_PATH || '').trim();
            const images = [];

            if ((process.env.IMG_ONE || '').trim()) {
              images.push(process.env.IMG_ONE.trim());
            }
            if ((process.env.IMG_LIST || '').trim()) {
              for (const s of process.env.IMG_LIST.split(',').map(x => x.trim()).filter(Boolean)) {
                images.push(s);
              }
            }

            if (!name) { core.setFailed('‚ùå application is required when application_details is not provided'); return; }
            if (!path) { core.setFailed('‚ùå deploy_path is required when application_details is not provided'); return; }

            apps.push({ name, path, images });
          }

          core.setOutput('apps', JSON.stringify(apps));
          core.setOutput('count', String(apps.length));


    - name: Render manifests with Nunjucks (Jinja2-style)
      id: render
      if: ${{ inputs.delete_only == false }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ steps.apps.outputs.apps }}
        CLUSTER_NAME: ${{ steps.env.outputs.cluster }}
        DNS_ZONE: ${{ steps.env.outputs.dns_zone }}
        NAMESPACE: ${{ inputs.namespace }}
        APPLICATION_DEFAULT: ${{ inputs.application }}
        CONTAINER_REGISTRY: ${{ steps.env.outputs.container_registry }}
        UAMI_VARS: ${{ steps.env.outputs.uami_vars }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const nunjucks = require(path.join(process.env.GITHUB_WORKSPACE, 'reusable', 'nunjucks.js'));

          const apps = JSON.parse(process.env.APPS || '[]');
          core.info(`üìù Apps to render: ${apps.map(a => a.name).join(', ')}`);

          let dirs = [];

          // Base vars
          const vars = {
            cluster_name: process.env.CLUSTER_NAME,
            dns_zone: process.env.DNS_ZONE,
            zone_nm: process.env.DNS_ZONE,
            namespace: process.env.NAMESPACE,
          };
          core.info(`üåç Base vars: ${JSON.stringify(vars)}`);

          // Merge in UAMI vars (client IDs keyed by uami_name)
          try {
            const uamiVars = JSON.parse(process.env.UAMI_VARS || '{}');
            Object.assign(vars, uamiVars);
            core.info(`üîë Injected UAMI vars: ${Object.keys(uamiVars).join(', ')}`);
          } catch (err) {
            core.warning(`‚ö†Ô∏è Could not parse UAMI_VARS: ${err.message}`);
          }

          nunjucks.configure({ autoescape: false });

          function listFiles(dir) {
            return fs.readdirSync(dir, { withFileTypes: true })
              .flatMap(e => {
                const full = path.join(dir, e.name);
                return e.isDirectory() ? listFiles(full) : [full];
              });
          }

          for (const app of apps) {
            const srcDir = path.join('source', app.path);
            core.startGroup(`üìÇ Processing app=${app.name} path=${app.path} ‚Üí srcDir=${srcDir}`);
            dirs.push(srcDir);

            if (!fs.existsSync(srcDir)) {
              core.warning(`‚ö†Ô∏è Source dir not found for app '${app.name}' at ${srcDir}`);
              core.endGroup();
              continue;
            }

            const files = listFiles(srcDir);
            core.info(`Found ${files.length} files for app '${app.name}'`);
            files.forEach(f => core.info("  - " + f));

            for (const f of files) {
              if (/\.(ya?ml|json)$/i.test(f) && !/notemplate\.ya?ml$/i.test(f)) {
                const template = fs.readFileSync(f, 'utf8');
                const rendered = nunjucks.renderString(template, vars);
                fs.writeFileSync(f, rendered, 'utf8');

                // Detect unresolved placeholders
                if (rendered.includes("{{")) {
                  core.warning(`‚ö†Ô∏è Unresolved placeholders remain in ${f}`);
                }

                core.info(`‚úÖ Rendered ${f}`);
              } else {
                core.debug(`Skipping non-YAML/JSON file: ${f}`);
              }
            }
            core.endGroup();
          }

          return dirs.join("\n");



    - name: Copy manifests to CD repo
      id: copy
      if: ${{ inputs.delete_only == false }}
      uses: actions/github-script@v7
      env:
        CLUSTER_NAME: ${{ steps.env.outputs.cluster }}
        NAMESPACE: ${{ inputs.namespace }}
        RENDERED_DIRS: ${{ steps.render.outputs.result }}
        APPS: ${{ steps.apps.outputs.apps }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          const cluster = process.env.CLUSTER_NAME;
          const namespace = process.env.NAMESPACE;
          const renderedDirs = (process.env.RENDERED_DIRS || '').trim().split('\n').filter(Boolean);
          const apps = JSON.parse(process.env.APPS || '[]');

          // ‚úÖ Copy into the continuous-deployment repo
          const cdRoot = path.join('continuous-deployment', cluster, namespace);
          const cdRootRel = path.join(cluster, namespace);
          fs.mkdirSync(cdRoot, { recursive: true });

          // assume apps[] order matches renderedDirs[] order
          renderedDirs.forEach((dir, i) => {
            const app = apps[i];
            if (!app) return;

            const destDir = path.join(cdRoot, app.name);

            // Delete just the app‚Äôs directory first
            if (fs.existsSync(destDir)) {
              console.log(`Removing old directory for app ${app.name}: ${destDir}`);
              execSync(`rm -rf "${destDir}"`);
            }

            fs.mkdirSync(destDir, { recursive: true });
            console.log(`Copying ${dir} -> ${destDir}`);
            execSync(`cp -r "${dir}/." "${destDir}/"`, { stdio: 'inherit' });
          });

          core.setOutput('cd_path', cdRoot);
          core.setOutput('cd_path_rel', cdRootRel);

    - name: Create JSON for cluster restore
      id: create-json
      uses: actions/github-script@v7
      env:
        CLUSTER: ${{ steps.env.outputs.cluster }}
        NAMESPACE: ${{ steps.env.outputs.namespace || inputs.namespace }}
        APPS: ${{ steps.apps.outputs.apps }}
        CD_REPO: ${{ inputs.cd_repo }}
        CD_REPO_ORG: ${{ inputs.cd_repo_org }}
        OVERLAY_DIR: ${{ inputs.overlay_dir }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const workspace = process.env.GITHUB_WORKSPACE;
          const cluster = process.env.CLUSTER;
          const namespace = process.env.NAMESPACE || 'default';
          const overlayDir = (process.env.OVERLAY_DIR || '').trim();
          const apps = JSON.parse(process.env.APPS || '[]');

          if (!cluster) {
            core.setFailed("‚ùå Cluster name not resolved from environment config");
            return;
          }

          if (apps.length === 0) {
            core.warning("‚ö†Ô∏è No applications found ‚Äî skipping create.json generation");
            return;
          }

          for (const a of apps) {
            // Keep same file location (per app)
            const outputDir = path.join(workspace, 'continuous-deployment', cluster, namespace, a.name);
            fs.mkdirSync(outputDir, { recursive: true });

            const payload = {
              cluster,
              namespace,
              overlay_dir: overlayDir,  // ‚¨ÖÔ∏è New top-level field
              applications: [
                {
                  name: a.name,
                  repo: `https://github.com/${process.env.CD_REPO_ORG}/${process.env.CD_REPO}`,
                  path: a.path              // Leave path as-is (no overlays)
                }
              ]
            };

            const outputFile = path.join(outputDir, 'create.json');
            fs.writeFileSync(outputFile, JSON.stringify(payload, null, 2));
            core.info(`üßæ Wrote ${outputFile} for ${a.name} (overlay_dir=${overlayDir || 'default'})`);
          }

          core.info(`‚úÖ Finished writing create.json for ${apps.length} app(s)`);



    - name: Setup Kustomize
      if: ${{ inputs.delete_only == false }}
      uses: imranismail/setup-kustomize@v2
      with:
        kustomize-version: ${{ inputs.kustomize_version }}

    - name: Patch image tag(s) (per app)
      if: ${{ inputs.image_tag != '' && inputs.delete_only == false  }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ steps.apps.outputs.apps }}
        CD_PATH: ${{ steps.copy.outputs.cd_path }}
        IMAGE_TAG: ${{ inputs.image_tag }}
        OVERLAY_DIR: ${{ inputs.overlay_dir }}
        CONTAINER_REGISTRY: ${{ steps.env.outputs.container_registry }}
      with:
        script: |
          const { execSync } = require('child_process');
          const apps = JSON.parse(process.env.APPS || '[]');
          const overlayDir = (process.env.OVERLAY_DIR || '').trim();
          const registry = process.env.CONTAINER_REGISTRY.replace(/\/+$/, ''); // strip trailing slash if any

          for (const app of apps) {
            // Normalized layout: just app.name (+ overlays if defined)
            const base = overlayDir
              ? `${process.env.CD_PATH}/${app.name}/overlays/${overlayDir}`
              : `${process.env.CD_PATH}/${app.name}`;

            if ((app.images || []).length === 0) continue;

            for (const img of app.images) {
              // full replacement: <registry>/<image>:<tag>
              const newImage = `${registry}/${img}:${process.env.IMAGE_TAG}`;
              execSync(
                `bash -lc 'cd "${base}" && kustomize edit set image "${img}=${newImage}"'`,
                { stdio: 'inherit' }
              );
            }
          }

    - name: Replace old Traefik CRD API version
      if: ${{ inputs.delete_only == false }}
      run: |
        echo "üîé Replacing traefik.containo.us/v1alpha1 ‚Üí traefik.io/v1alpha1"
        find "${{ steps.copy.outputs.cd_path }}" -type f \( -name "*.yaml" -o -name "*.yml" \) \
          -exec sed -i 's#traefik\.containo\.us/v1alpha1#traefik.io/v1alpha1#g' {} +


    - name: Upload CD repo manifests
      if: ${{ always() && inputs.delete_only == false }}
      uses: actions/upload-artifact@v4
      with:
        name: templated-source-manifests-${{ steps.env.outputs.cluster }}-${{ fromJSON(steps.apps.outputs.apps)[0].name }}
        path: ${{ steps.copy.outputs.cd_path }}/${{ fromJSON(steps.apps.outputs.apps)[0].name }}


    - name: Debug structure
      if: ${{ inputs.debug && inputs.delete_only == false }}
      run: find "${{ steps.copy.outputs.cd_path }}" || echo "Nothing copied!"

    - name: Run kustomize build (concat per app)
      id: kustomize
      if: ${{ inputs.delete_only == false }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ steps.apps.outputs.apps }}
        CD_PATH: ${{ steps.copy.outputs.cd_path }}
        OVERLAY_DIR: ${{ inputs.overlay_dir }}
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');
          const apps = JSON.parse(process.env.APPS || '[]');
          const overlayDir = (process.env.OVERLAY_DIR || '').trim();
          const outFile = `${process.env.GITHUB_WORKSPACE}/build-output.yaml`;

          fs.writeFileSync(outFile, '');
          let first = true;

          for (const app of apps) {
            const dir = overlayDir
              ? `${process.env.CD_PATH}/${app.name}/overlays/${overlayDir}`
              : `${process.env.CD_PATH}/${app.name}`;

            const yaml = execSync(`bash -lc 'cd "${dir}" && kustomize build --load-restrictor=LoadRestrictionsNone .'`, { encoding: 'utf8' });
            fs.appendFileSync(outFile, (first ? '' : '\n---\n') + yaml);
            first = false;
          }

          return outFile;


    - name: Upload built manifest as artifact
      if: ${{ always() && inputs.delete_only == false }}
      uses: actions/upload-artifact@v4
      with:
        name: built-kustomize-manifest-${{ steps.env.outputs.cluster }}-${{ fromJSON(steps.apps.outputs.apps)[0].name }}
        path: build-output.yaml


    - name: Commit and squash-merge changes
      uses: gitopsmanager/Auto-Commit-Squash-Merge@v1
      with:
        token: ${{ steps.generate_token.outputs.token }}
        repo_owner: ${{ inputs.cd_repo_org }}
        repo_name: ${{ inputs.cd_repo }}
        namespace: ${{ inputs.namespace }}
        cluster: ${{ steps.env.outputs.cluster }}
        app_name: ${{ fromJSON(steps.apps.outputs.apps)[0].name }}
        repo_path_rel: ${{ steps.copy.outputs.cd_path_rel }}
        delete_only: ${{ inputs.delete_only }}


 
    - name: Construct ArgoCD URL
      id: build_argo_url
      run: |
        echo "url=https://${{ steps.env.outputs.cluster }}-argocd-argocd-web-ui.${{ steps.env.outputs.dns_zone }}" >> $GITHUB_OUTPUT

    - name: Manage ArgoCD Applications
      uses: gitopsmanager/ArgoCD-Manage-Applications@v1
      with:
        argocd_url: ${{ steps.build_argo_url.outputs.url }}
        argocd_auth_token: ${{ inputs.argocd_auth_token }}
        argocd_username:  ${{ secrets.ARGOCD_USERNAME }}
        argocd_password: ${{ secrets.ARGOCD_PASSWORD }}
        insecure_argo: ${{ inputs.insecure_argo }}
        argocd_ca_cert: ${{ secrets.ARGOCD_CA_CERT }}
        namespace: ${{ inputs.namespace }}
        cd_repo: ${{ inputs.cd_repo }}
        cd_path_rel: ${{ steps.copy.outputs.cd_path_rel }}
        cd_repo_org: ${{ inputs.cd_repo_org }}
        overlay_dir: ${{ inputs.overlay_dir }}
        apps: ${{ steps.apps.outputs.apps }}
        delete_first: ${{ inputs.delete_first }}
        delete_only: ${{ inputs.delete_only }}
        skip_status_check: ${{ inputs.skip_status_check }}




