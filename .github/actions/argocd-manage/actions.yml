name: "ArgoCD Manage Applications"
description: "Handles full ArgoCD lifecycle: auth, connect, delete, create, sync, wait-for-sync. Supports no-fail mode for restore cluster runs."

inputs:
  argocd_auth_token:
    required: false
  argocd_username:
    required: false
  argocd_password:
    required: false
  insecure_argo:
    required: false
    default: false
  argocd_ca_cert:
    required: false
  namespace:
    required: true
  cd_repo:
    required: true
  cd_repo_org:
    required: true
  overlay_dir:
    required: false
    default: ""
  apps:
    description: "JSON array of {name, path, images}"
    required: true
  delete_first:
    required: false
    default: false
  delete_only:
    required: false
    default: false
  skip_status_check:
    required: false
    default: false
  no_fail:
    description: "If true, ArgoCD create/sync/wait errors are logged as warnings but do not fail the job."
    required: false
    default: false

outputs:
  argocd_url:
  curl_ssl_flags:
  token:
  baselines:

runs:
  using: composite
  steps:

    - name: Resolve ArgoCD auth
      id: resolve_auth
      shell: bash
      env:
        IN_TOKEN: ${{ inputs.argocd_auth_token }}
        IN_USER: ${{ inputs.argocd_username }}
        IN_PASS: ${{ inputs.argocd_password }}
        SEC_USER: ${{ secrets.ARGOCD_USERNAME }}
        SEC_PASS: ${{ secrets.ARGOCD_PASSWORD }}
      run: |
        set -euo pipefail
        if [ -n "${IN_TOKEN:-}" ]; then
          echo "mode=token" >> "$GITHUB_OUTPUT"
          echo "token=$IN_TOKEN" >> "$GITHUB_OUTPUT"
        elif [ -n "${IN_USER:-}" ] && [ -n "${IN_PASS:-}" ]; then
          echo "mode=basic" >> "$GITHUB_OUTPUT"
          echo "username=$IN_USER" >> "$GITHUB_OUTPUT"
          echo "password=$IN_PASS" >> "$GITHUB_OUTPUT"
        elif [ -n "${SEC_USER:-}" ] && [ -n "${SEC_PASS:-}" ]; then
          echo "mode=basic" >> "$GITHUB_OUTPUT"
          echo "username=$SEC_USER" >> "$GITHUB_OUTPUT"
          echo "password=$SEC_PASS" >> "$GITHUB_OUTPUT"
        else
          echo "‚ùå No ArgoCD auth provided."
          exit 1
        fi

    - name: Debug ARGOCD_CA_CERT presence
      run: |
        if [ -z "${ARGOCD_CA_CERT}" ]; then
          echo "‚ùå ARGOCD_CA_CERT is not set"
        else
          echo "‚úÖ ARGOCD_CA_CERT is set (length: ${#ARGOCD_CA_CERT})"
        fi
      shell: bash
      env:
        ARGOCD_CA_CERT: ${{ inputs.argocd_ca_cert }}

    - name: Set ArgoCD connection (token & URLs)
      id: argocd_conn
      uses: actions/github-script@v7
      env:
        MODE: ${{ steps.resolve_auth.outputs.mode }}
        TOKEN: ${{ steps.resolve_auth.outputs.token }}
        USERNAME: ${{ steps.resolve_auth.outputs.username }}
        PASSWORD: ${{ steps.resolve_auth.outputs.password }}
        ARGOCD_CA_CERT: ${{ inputs.argocd_ca_cert }}
        CLUSTER: ${{ github.event.inputs.target_cluster || github.event.inputs.cluster }}
        DNS_ZONE: ${{ github.event.inputs.dns_zone }}
        INSECURE_ARGO: ${{ inputs.insecure_argo }}
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');
          const cluster = process.env.CLUSTER;
          const dnsZone = process.env.DNS_ZONE;
          const argocdUrl = `https://${cluster}-argocd-argocd-web-ui.${dnsZone}`;

          let curlSslFlags = "";
          if (String(process.env.INSECURE_ARGO) === "true") {
            curlSslFlags = "-k";
            core.warning("‚ö†Ô∏è Using insecure connection (curl -k).");
          } else if (process.env.ARGOCD_CA_CERT) {
            let cert = process.env.ARGOCD_CA_CERT;
            if (cert.includes('\\n')) cert = cert.replace(/\\n/g, '\n');
            fs.writeFileSync('/tmp/argocd-ca.crt', cert);
            curlSslFlags = "--cacert /tmp/argocd-ca.crt";
            core.info("‚úÖ Using provided CA cert with curl.");
          }

          let finalToken = process.env.TOKEN;
          if (process.env.MODE !== "token") {
            const body = JSON.stringify({ username: process.env.USERNAME, password: process.env.PASSWORD });
            const cmd = `curl -s ${curlSslFlags} -X POST "${argocdUrl}/api/v1/session" -H "Content-Type: application/json" -d '${body.replace(/'/g,"'\\''")}'`;
            const resp = execSync(cmd).toString();
            try {
              finalToken = JSON.parse(resp).token;
            } catch {
              core.error(`Response: ${resp}`);
              core.setFailed("‚ùå Failed to parse ArgoCD session response");
              return;
            }
          }
          if (!finalToken) {
            core.setFailed("‚ùå Failed to obtain ArgoCD token.");
            return;
          }
          core.info("‚úÖ Successfully obtained ArgoCD token.");
          core.setOutput('argocd_url', argocdUrl);
          core.setOutput('curl_ssl_flags', curlSslFlags);
          core.setOutput('token', finalToken);

    - name: Delete ArgoCD apps (per app)
      if: ${{ inputs.delete_first == 'true' || inputs.delete_only == 'true' }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ inputs.apps }}
        ARGOCD_URL: ${{ steps.argocd_conn.outputs.argocd_url }}
        ARGOCD_TOKEN: ${{ steps.argocd_conn.outputs.token }}
        CURL_SSL_FLAGS: ${{ steps.argocd_conn.outputs.curl_ssl_flags }}
        NAMESPACE: ${{ inputs.namespace }}
        NO_FAIL: ${{ inputs.no_fail }}
      with:
        script: |
          const { execSync } = require('child_process');
          const apps = JSON.parse(process.env.APPS || '[]');
          const allowSoftFail = String(process.env.NO_FAIL) === "true";
          function failOrWarn(msg) {
            if (allowSoftFail) core.warning(msg); else core.setFailed(msg);
          }
          function httpCode(cmd) {
            return parseInt(execSync(`${cmd} -o /dev/null -w "%{http_code}"`).toString().trim(), 10);
          }
          for (const app of apps) {
            const appName = `${process.env.NAMESPACE}-${app.name}`;
            const appUrl = `${process.env.ARGOCD_URL}/api/v1/applications/${appName}`;
            core.info(`üóëÔ∏è Deleting ArgoCD Application: ${appName}`);
            const delCmd = `curl -s ${process.env.CURL_SSL_FLAGS} -X DELETE "${appUrl}" -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" -H "Content-Type: application/json"`;
            const code = httpCode(delCmd);
            core.info(`Delete response HTTP ${code}`);
            if (![200,202,204].includes(code)) {
              failOrWarn(`‚ùå Failed to delete ${appName}: HTTP ${code}`);
              continue;
            }
            const timeout = Date.now() + 120000;
            while (Date.now() < timeout) {
              const checkCmd = `curl -s ${process.env.CURL_SSL_FLAGS} -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" "${appUrl}"`;
              const checkCode = httpCode(checkCmd);
              if (checkCode === 403) {
                core.info(`‚úÖ ${appName} deleted (HTTP 403)`);
                break;
              }
              core.info(`‚è≥ Still deleting ${appName} (HTTP ${checkCode})...`);
              await new Promise(r => setTimeout(r, 5000));
            }
          }

    - name: Check or create ArgoCD applications (per app)
      if: ${{ inputs.delete_only == 'false' }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ inputs.apps }}
        CD_PATH_REL: ${{ inputs.cd_repo }}
        OVERLAY_DIR: ${{ inputs.overlay_dir }}
        CD_REPO: ${{ inputs.cd_repo }}
        CD_REPO_ORG: ${{ inputs.cd_repo_org }}
        ARGOCD_URL: ${{ steps.argocd_conn.outputs.argocd_url }}
        ARGOCD_TOKEN: ${{ steps.argocd_conn.outputs.token }}
        CURL_SSL_FLAGS: ${{ steps.argocd_conn.outputs.curl_ssl_flags }}
        NAMESPACE: ${{ inputs.namespace }}
        NO_FAIL: ${{ inputs.no_fail }}
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');
          const nunjucks = require('./nunjucks.js');
          const apps = JSON.parse(process.env.APPS || '[]');
          const allowSoftFail = String(process.env.NO_FAIL) === "true";
          function failOrWarn(msg) {
            if (allowSoftFail) core.warning(msg); else core.setFailed(msg);
          }
          function curlJson(url) {
            try { return execSync(`curl -s ${process.env.CURL_SSL_FLAGS} -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" "${url}"`).toString(); }
            catch { return ""; }
          }
          for (const app of apps) {
            const appName = `${process.env.NAMESPACE}-${app.name}`;
            const statusUrl = `${process.env.ARGOCD_URL}/api/v1/applications/${appName}`;
            const basePath = path.join(process.env.CD_PATH_REL, app.name, 'overlays', process.env.OVERLAY_DIR);
            const status = curlJson(statusUrl);
            try {
              if (status) {
                const existing = JSON.parse(status);
                if (existing?.spec?.source?.path === basePath) {
                  core.info(`‚úÖ Argo app ${appName} exists with correct path.`);
                  continue;
                } else {
                  core.warning(`‚ö†Ô∏è Path mismatch for ${appName}, recreating`);
                  execSync(`curl -s ${process.env.CURL_SSL_FLAGS} -X DELETE "${statusUrl}" -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}"`);
                }
              }
              const template = fs.readFileSync('reusable/templates/argocd-app-template-v6.json', 'utf8');
              const rendered = nunjucks.renderString(template, {
                APP_NAME: appName,
                NAMESPACE: process.env.NAMESPACE,
                CD_REPO: process.env.CD_REPO,
                CD_REPO_ORG: process.env.CD_REPO_ORG,
                CD_PATH: basePath
              });
              execSync(`curl -s ${process.env.CURL_SSL_FLAGS} -X POST "${process.env.ARGOCD_URL}/api/v1/applications" -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" -H "Content-Type: application/json" -d '${rendered.replace(/'/g,"'\\''")}'`);
              core.info(`‚úÖ Created Argo app ${appName}`);
            } catch (err) {
              failOrWarn(`‚ùå Error creating ${appName}: ${err.message}`);
            }
          }

    - name: Sync ArgoCD apps (per app)
      id: sync
      if: ${{ inputs.delete_only == 'false' }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ inputs.apps }}
        ARGOCD_URL: ${{ steps.argocd_conn.outputs.argocd_url }}
        ARGOCD_TOKEN: ${{ steps.argocd_conn.outputs.token }}
        CURL_SSL_FLAGS: ${{ steps.argocd_conn.outputs.curl_ssl_flags }}
        NAMESPACE: ${{ inputs.namespace }}
        NO_FAIL: ${{ inputs.no_fail }}
      with:
        script: |
          const { execSync } = require('child_process');
          const apps = JSON.parse(process.env.APPS || '[]');
          const baselines = {};
          const allowSoftFail = String(process.env.NO_FAIL) === "true";
          function failOrWarn(msg) {
            if (allowSoftFail) core.warning(msg); else core.setFailed(msg);
          }
          for (const app of apps) {
            const appName = `${process.env.NAMESPACE}-${app.name}`;
            const statusUrl = `${process.env.ARGOCD_URL}/api/v1/applications/${appName}`;
            let baseline = 0;
            try {
              const status = execSync(`curl -s ${process.env.CURL_SSL_FLAGS} -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" "${statusUrl}"`).toString();
              const json = JSON.parse(status);
              if (json?.status?.operationState?.startedAt)
                baseline = new Date(json.status.operationState.startedAt).getTime();
            } catch {}
            baselines[appName] = baseline;
            try {
              execSync(`curl -s ${process.env.CURL_SSL_FLAGS} -X POST "${statusUrl}/sync" -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" -H "Content-Type: application/json" -d '{"prune":true,"force":true}'`);
              core.info(`üöÄ Force-prune sync triggered: ${appName}`);
            } catch (err) {
              failOrWarn(`‚ùå Failed to sync ${appName}: ${err.message}`);
            }
          }
          core.setOutput('baselines', JSON.stringify(baselines));

    - name: Wait for ArgoCD sync (per app)
      if: ${{ inputs.skip_status_check == 'false' && inputs.delete_only == 'false' }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ inputs.apps }}
        ARGOCD_URL: ${{ steps.argocd_conn.outputs.argocd_url }}
        ARGOCD_TOKEN: ${{ steps.argocd_conn.outputs.token }}
        CURL_SSL_FLAGS: ${{ steps.argocd_conn.outputs.curl_ssl_flags }}
        NAMESPACE: ${{ inputs.namespace }}
        BASELINES: ${{ steps.sync.outputs.baselines }}
        NO_FAIL: ${{ inputs.no_fail }}
      with:
        script: |
          const { execSync } = require('child_process');
          const apps = JSON.parse(process.env.APPS || '[]');
          const baselines = JSON.parse(process.env.BASELINES || '{}');
          const allowSoftFail = String(process.env.NO_FAIL) === "true";
          function failOrWarn(msg) {
            if (allowSoftFail) core.warning(msg); else core.setFailed(msg);
          }
          function allResourcesSynced(json) {
            const results = json?.status?.operationState?.syncResult?.resources || json?.status?.operationState?.results || [];
            return Array.isArray(results) && results.length > 0 && results.every(r => r.status === 'Synced' || r.hookPhase === 'Succeeded');
          }
          for (const app of apps) {
            const appName = `${process.env.NAMESPACE}-${app.name}`;
            const statusUrl = `${process.env.ARGOCD_URL}/api/v1/applications/${appName}`;
            const baseline = baselines[appName] || 0;
            core.startGroup(`‚è≥ Waiting for sync of ${appName}, baseline=${baseline}`);
            let ok = false, lastPhase, lastSync, lastHealth, consecutiveErrors = 0;
            for (let i = 0; i < 36; i++) {
              try {
                const status = execSync(`curl -s ${process.env.CURL_SSL_FLAGS} -H "Authorization: Bearer ${process.env.ARGOCD_TOKEN}" "${statusUrl}"`).toString();
                const json = JSON.parse(status);
                const op = json?.status?.operationState;
                lastPhase = op?.phase;
                lastSync = json?.status?.sync?.status;
                lastHealth = json?.status?.health?.status;
                core.info(`üîÑ Iteration ${i + 1}/36 for ${appName}: phase=${lastPhase}, sync=${lastSync}, health=${lastHealth}`);
                const startedAt = op?.startedAt ? new Date(op.startedAt).getTime() : 0;
                const allSynced = allResourcesSynced(json);
                if (startedAt > baseline) {
                  if (lastHealth === 'Degraded') {
                    failOrWarn(`‚ùå ${appName} is Synced but health=Degraded.`);
                    break;
                  }
                  if (lastPhase === 'Succeeded' && lastSync === 'Synced' && lastHealth === 'Healthy') {
                    core.info(`‚úÖ ${appName} synced after baseline and is Healthy.`);
                    ok = true;
                    break;
                  } else if (allSynced && lastHealth === 'Healthy') {
                    core.info(`‚úÖ ${appName} has all synced results and is Healthy.`);
                    ok = true;
                    break;
                  }
                } else if (lastSync === 'Synced' && lastHealth === 'Healthy') {
                  core.info(`‚úÖ ${appName} was already Synced and Healthy before baseline.`);
                  ok = true;
                  break;
                }
              } catch (err) {
                consecutiveErrors++;
                if (consecutiveErrors > 3) {
                  failOrWarn(`‚ùå Failed to fetch status for ${appName}: ${err.message}`);
                  break;
                } else {
                  core.warning(`‚ö†Ô∏è Failed to fetch status for ${appName} (attempt ${consecutiveErrors}): ${err.message}`);
                }
              }
              await new Promise(r => setTimeout(r, 10000));
            }
            if (!ok) failOrWarn(`‚ùå Sync did not complete in time for ${appName} (phase=${lastPhase}, sync=${lastSync}, health=${lastHealth})`);
            core.endGroup();
          }

