# deploy.yaml
# Copyright (c) 2025 Affinity7 Consulting Ltd
# Version: v2 (reusable, minimal auth precedence)
# SPDX-License-Identifier: MIT

on:
  workflow_call:
    inputs:
      github_runner:
        required: true
        type: string
      namespace:
        required: true
        type: string
      target_environment:
        description: >
          The environment to deploy to (e.g., `dev`, `qa`, `prod`).

          - If the environment maps to a **single cluster** in `env_map`, this is all you need.
          - If the environment maps to **multiple clusters**, you must also set `target_cluster`.
        required: true
        default: "dev"
        type: string

      # REQUIRED when env has >1 clusters
      target_cluster:
        description: >
          The specific cluster to deploy to when the selected target_environment
          has more than one cluster in `env_map`.

          - For single-cluster environments (like `dev`, `qa`), leave this empty.
          - For multi-cluster environments (like `prod` with both `aks-prod-weu` and `aks-prod-use`),
            you must provide one of the valid cluster names from `env_map`.

          Example: `aks-prod-weu`   
        required: false
        default: ""
        type: string
      ref:
        description: "The github ref to use for checking out files"
        required: false
        type: string
        default: ${{ github.ref || github.sha }}
      delete_first:
        description: "Delete the namespaced app first before deploying it."
        required: false
        type: boolean        
      delete_only:
        description: "Delete ArgoCD app(s) without redeploying"
        required: false
        type: boolean
        default: false
      cd_repo:
        required: true
        type: string
      cd_repo_org:
        required: true
        type: string
      github_environment:
        required: false
        type: string
      # Mode A (single app)
      application:
        required: false
        type: string
      deploy_path:
        description: "The repo path to the deployment files"
        required: false
        type: string
        default: Deployments
      image_tag:
        required: false
        type: string
      image_base_name:
        required: false
        type: string
      image_base_names:
        required: false
        type: string
      overlay_dir:
        required: true
        type: string
        default: ""

      # Mode B (multi app)
      application_details:
        description: >-
          JSON array where each item maps:
          { "name" => application, "images" => image_base_names[], "path" => deploy_path }
          Example:
          [
            {"name":"app1","images":["repo/app1","repo/sidecar"],"path":"services/app1/overlays/prod"},
            {"name":"app2","images":["repo/app2"],"path":"apps/app2/overlays/prod"}
          ]
        required: false
        type: string
        default: ''

      # Environment map (single supported shape)
      env_map:
        description: >-
          ONLY this JSON shape is supported:
          {
            "<env>": {
              "cluster_count": N,
              "clusters": [
                { "cluster": "...", "dns_zone": "...", "container_registry": "...", "uami_map": [...] }
              ]
            }
          }
        required: false
        type: string

      # Argo / misc
      argocd_auth_token:
        required: false
        type: string
      argocd_username:
        required: false
        type: string
      argocd_password:
        required: false
        type: string
      kustomize_version:
        required: false
        type: string
        default: "5.0.1"
      skip_status_check:
        required: false
        default: false
        type: boolean
      insecure_argo:
        required: false
        default: false
        type: boolean
      debug:
        required: false
        type: boolean
        default: false
    secrets:
      CONTINUOUS_DEPLOYMENT_GH_APP_ID:
        required: true
      CONTINUOUS_DEPLOYMENT_GH_APP_PRIVATE_KEY:
        required: true
      ARGOCD_CA_CERT:
        required: false
      ARGOCD_USERNAME:
        required: false
      ARGOCD_PASSWORD:
        required: false

jobs:
  deploy:
    name: >-
      ${{ inputs.target_environment }}${{ inputs.target_cluster != '' && format(' - {0}', inputs.target_cluster) || '' }}
    runs-on: ${{ inputs.github_runner }}
    environment: ${{ inputs.github_environment }}
    outputs:
      cd_path: ${{ steps.cdroot.outputs.cd_root }}
    steps:
    - name: Checkout repo
      if: ${{ inputs.delete_only == false }}
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        repository: ${{ github.repository }}
        path: source
        ref: ${{ inputs.ref }}


    - name: Report usage metrics (non-blocking)
      uses: actions/github-script@v7
      continue-on-error: true
      timeout-minutes: 0.5
      env:
        USAGE_ENDPOINT: https://gitopsmanager.io/github-action-metrics
      with:
        script: |
          const fetch = global.fetch;
          const endpoint = process.env.USAGE_ENDPOINT;
          if (!endpoint) {
            core.warning('‚ùå USAGE_ENDPOINT is not defined');
            return;
          }

          const repoFull = process.env.GITHUB_REPOSITORY || "";
          const [org, repo] = repoFull.split("/");

          const payload = {
            org,
            repo,
            action: "deploy", // or "build" etc.
            timestamp: new Date().toISOString(),
          };

          core.info(`üìä Sending metrics: ${JSON.stringify(payload)}`);

          try {
            const resp = await fetch(endpoint, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });

            const text = await resp.text(); // read raw body once

            if (resp.ok) {
              core.info(`‚úÖ Usage metrics reported successfully (${resp.status}).`);
              core.info(`üîç Response body: ${text}`);
            } else {
              core.warning(`‚ö†Ô∏è Metrics report failed: HTTP ${resp.status}`);
              core.warning(`Response body: ${text}`);
            }
          } catch (err) {
            core.warning(`‚ùå Metrics request threw: ${err.message}`);
          }



    - name: Generate GitHub App token
      id: generate_token
      uses: actions/create-github-app-token@v2
      with:
        app-id: ${{ secrets.CONTINUOUS_DEPLOYMENT_GH_APP_ID }}
        private-key: ${{ secrets.CONTINUOUS_DEPLOYMENT_GH_APP_PRIVATE_KEY }}
        owner: ${{ inputs.cd_repo_org }}
        repositories: ${{ inputs.cd_repo }}



    - name: Checkout reusable workflow repo
      if: ${{ inputs.delete_only == false }}
      uses: actions/checkout@v4
      with:
        repository: gitopsmanager/k8s-deploy
        ref: v2
        path: reusable

    - name: Checkout continuous-deployment repo
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.cd_repo_org }}/${{ inputs.cd_repo }}
        token: ${{ steps.generate_token.outputs.token }}
        path: continuous-deployment

    - name: Detect cloud
      id: cloud
      if: ${{ inputs.delete_only == false }}
      uses: gitopsmanager/detect-cloud@v1
      with:
        timeout-ms: 800


    - name: Warn if GitHub-hosted (unknown cloud)
      if: ${{ steps.cloud.outputs.provider == 'unknown' && inputs.delete_only == false  }}
      run: |
        echo "‚ö†Ô∏è Running on a GitHub-hosted runner."
        echo "Workload Identity mappings for AWS/Azure self-hosted runners will not apply."

    - name: Import ENV_MAP from runner
      shell: bash
      run: |
        printf "ENV_MAP<<EOF\n%s\nEOF\n" "$ENV_MAP" >> $GITHUB_ENV


    # Strict env_map parsing + cluster selection (with ENV_MAP fallback)
    - name: Load environment config (JSON)
      id: env
      uses: actions/github-script@v7
      env:
        INLINE_ENV_MAP: ${{ inputs.env_map }}   # workflow input (preferred)
        ENV_MAP: ${{ env.ENV_MAP }}            # fallback env var (e.g., injected from ConfigMap on self-hosted)
        ENVIRONMENT: ${{ inputs.target_environment }}
        CLUSTER_IN: ${{ inputs.target_cluster }}
        NAMESPACE: ${{ inputs.namespace }}
      with:
        script: |
          const sourceInput = (process.env.INLINE_ENV_MAP || '').trim();
          const sourceEnv   = (process.env.ENV_MAP || '').trim();
          const raw = sourceInput || sourceEnv;

          if (!raw) {
            core.setFailed('‚ùå No env_map provided. Pass inputs.env_map OR set ENV_MAP environment variable.');
            return;
          }
          core.info(`Using env_map from ${sourceInput ? 'workflow input (inputs.env_map)' : 'ENV_MAP environment variable'}.`);

          let map;
          try { map = JSON.parse(raw); }
          catch (err) { core.setFailed(`‚ùå env_map is not valid JSON: ${err.message}`); return; }

          const envName   = (process.env.ENVIRONMENT || '').trim();
          const clusterIn = (process.env.CLUSTER_IN || '').trim();

          let selected;

          if (clusterIn) {
            // Cluster override: search ALL clusters across ALL environments
            const allClusters = Object.entries(map)
              .flatMap(([env, val]) => (val.clusters || []).map(c => ({ ...c, __env: env })));

            selected = allClusters.find(c => String(c.cluster).toLowerCase() === clusterIn.toLowerCase());
            if (!selected) {
              const available = allClusters.map(c => `${c.cluster} (env=${c.__env})`);
              core.setFailed(`‚ùå target_cluster '${clusterIn}' not found. Available: ${available.join(', ')}`);
              return;
            }

            if (selected.__env !== envName) {
              core.warning(`‚ö†Ô∏è target_cluster '${clusterIn}' belongs to env '${selected.__env}', not requested env '${envName}'. Proceeding anyway.`);
            }

            core.info(`Cluster override: using cluster '${selected.cluster}' from env '${selected.__env}'`);
          } else {
            // Normal environment-based selection
            if (!Object.prototype.hasOwnProperty.call(map, envName)) {
              core.setFailed(`‚ùå Environment '${envName}' not found. Available: ${Object.keys(map).join(', ')}`);
              return;
            }

            const entry = map[envName];
            if (!entry || typeof entry !== 'object' || !Array.isArray(entry.clusters)) {
              core.setFailed(`‚ùå env_map['${envName}'] must be { cluster_count, clusters: [...] }`);
              return;
            }
            if (entry.clusters.length === 0) {
              core.setFailed(`‚ùå env_map['${envName}'].clusters is empty`);
              return;
            }
            if (entry.clusters.length > 1) {
              const names = entry.clusters.map(c => c.cluster).filter(Boolean);
              core.setFailed(`‚ùå '${envName}' has multiple clusters. Provide target_cluster. Options: ${names.join(', ')}`);
              return;
            }

            selected = entry.clusters[0];
            core.info(`Selected single cluster '${selected.cluster}' from env '${envName}'`);
          }

          // Final validation + outputs
          const cluster   = String(selected.cluster || '');
          const dnsZone   = String(selected.dns_zone || '');
          const registry  = String(selected.container_registry || '');
          const uami      = Array.isArray(selected.uami_map) ? selected.uami_map : [];

          if (!cluster) { core.setFailed('‚ùå Selected cluster name is empty'); return; }
          if (!dnsZone) { core.setFailed(`‚ùå Cluster '${cluster}' is missing dns_zone`); return; }

          core.setOutput('cluster', cluster);
          core.setOutput('dns_zone', dnsZone);
          core.setOutput('container_registry', registry);
          core.setOutput('uami_map', JSON.stringify(uami));
          core.setOutput('namespace', process.env.NAMESPACE);




    - name: Export CD_ROOT
      id: cdroot
      run: |
        CD_ROOT="continuous-deployment/${{ steps.env.outputs.cluster }}/${{ inputs.namespace }}"
        echo "CD_ROOT=$CD_ROOT" >> "$GITHUB_ENV"
        echo "cd_root=$CD_ROOT" >> "$GITHUB_OUTPUT"

    - name: Export UAMI env vars (uami_name => client_id)
      id: uami
      if: ${{ inputs.delete_only == false }}
      uses: actions/github-script@v7
      env:
        UAMI_JSON: ${{ steps.env.outputs.uami_map }}
        CLUSTER: ${{ steps.env.outputs.cluster }}
      with:
        script: |
          const clusterName = (process.env.CLUSTER || '').trim();

          let arr = [];
          try { arr = JSON.parse(process.env.UAMI_JSON || '[]'); }
          catch { core.setFailed('‚ùå Selected cluster uami_map is not valid JSON'); return; }

          if (!Array.isArray(arr) || arr.length === 0) {
            core.info('No UAMI entries for selected cluster.');
            core.setOutput("uami_vars", "{}");
            return;
          }

          const seen = new Set();
          const exported = {};

          for (const [i, u] of arr.entries()) {
            let name = String(u.uami_name || '').trim();
            const rg   = String(u.uami_resource_group || '').trim();
            const cid  = String(u.client_id || '').trim();

            if (!name || !cid) {
              core.warning(`Skipping UAMI index ${i}: missing uami_name or client_id.`);
              continue;
            }

            // Remove "<clusterName>-" prefix if present
            const prefix = clusterName + "-";
            if (name.toLowerCase().startsWith(prefix.toLowerCase())) {
              name = name.substring(prefix.length);
            }

            // Replace '-' with '_'
            let varName = name.replace(/-/g, "_");

            // Ensure valid shell identifier
            if (!/^[A-Za-z_]/.test(varName)) varName = `_${varName}`;

            if (seen.has(varName)) {
              core.warning(`Duplicate UAMI var '${varName}' (rg='${rg}'). Skipping duplicate.`);
              continue;
            }

            exported[varName.toLowerCase()] = cid;
            seen.add(varName);
          }

          core.info("UAMI vars exported:");
          core.info(JSON.stringify(exported, null, 2));

          // Set JSON object as step output
          core.setOutput("uami_vars", JSON.stringify(exported));




    # Unify to a single apps[] list for either mode
    - name: Resolve apps (single or multi)
      id: apps
      uses: actions/github-script@v7
      env:
        APP_DETAILS: ${{ inputs.application_details }}
        APPLICATION: ${{ inputs.application }}
        DEPLOY_PATH: ${{ inputs.deploy_path }}
        IMG_ONE: ${{ inputs.image_base_name }}
        IMG_LIST: ${{ inputs.image_base_names }}
      with:
        script: |
          const detailsRaw = (process.env.APP_DETAILS || '').trim();
          let apps = [];

          if (detailsRaw) {
            let arr;
            try { arr = JSON.parse(detailsRaw); }
            catch (e) { core.setFailed(`‚ùå application_details is not valid JSON: ${e.message}`); return; }

            // Normalize to array if single object
            if (!Array.isArray(arr)) {
              core.info('application_details is a single object ‚Üí wrapping in an array');
              arr = [arr];
            }

            for (let i = 0; i < arr.length; i++) {
              const it = arr[i] || {};
              const name = String(it.name || '').trim();
              const path = String(it.path || '').trim();
              const images = Array.isArray(it.images) ? it.images.map(String) : [];

              if (!name) { core.setFailed(`‚ùå application_details[${i}].name is required`); return; }
              if (!path) { core.setFailed(`‚ùå application_details[${i}].path is required`); return; }

              apps.push({ name, path, images });
            }
          } else {
            // Single app mode (inputs)
            const name = (process.env.APPLICATION || '').trim();
            const path = (process.env.DEPLOY_PATH || '').trim();
            const images = [];

            if ((process.env.IMG_ONE || '').trim()) {
              images.push(process.env.IMG_ONE.trim());
            }
            if ((process.env.IMG_LIST || '').trim()) {
              for (const s of process.env.IMG_LIST.split(',').map(x => x.trim()).filter(Boolean)) {
                images.push(s);
              }
            }

            if (!name) { core.setFailed('‚ùå application is required when application_details is not provided'); return; }
            if (!path) { core.setFailed('‚ùå deploy_path is required when application_details is not provided'); return; }

            apps.push({ name, path, images });
          }

          core.setOutput('apps', JSON.stringify(apps));
          core.setOutput('count', String(apps.length));



    - name: Download Nunjucks UMD bundle
      if: ${{ inputs.delete_only == false }}
      run: |
        curl -sSL https://cdnjs.cloudflare.com/ajax/libs/nunjucks/3.2.4/nunjucks.min.js -o nunjucks.js


    - name: Render manifests with Nunjucks (Jinja2-style)
      id: render
      if: ${{ inputs.delete_only == false }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ steps.apps.outputs.apps }}
        CLUSTER_NAME: ${{ steps.env.outputs.cluster }}
        DNS_ZONE: ${{ steps.env.outputs.dns_zone }}
        NAMESPACE: ${{ inputs.namespace }}
        APPLICATION_DEFAULT: ${{ inputs.application }}
        CONTAINER_REGISTRY: ${{ steps.env.outputs.container_registry }}
        UAMI_VARS: ${{ steps.uami.outputs.uami_vars }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const nunjucks = require('./nunjucks.js');

          const apps = JSON.parse(process.env.APPS || '[]');
          core.info(`üìù Apps to render: ${apps.map(a => a.name).join(', ')}`);

          let dirs = [];

          // Base vars
          const vars = {
            cluster_name: process.env.CLUSTER_NAME,
            dns_zone: process.env.DNS_ZONE,
            zone_nm: process.env.DNS_ZONE,
            namespace: process.env.NAMESPACE,
          };
          core.info(`üåç Base vars: ${JSON.stringify(vars)}`);

          // Merge in UAMI vars (client IDs keyed by uami_name)
          try {
            const uamiVars = JSON.parse(process.env.UAMI_VARS || '{}');
            Object.assign(vars, uamiVars);
            core.info(`üîë Injected UAMI vars: ${Object.keys(uamiVars).join(', ')}`);
          } catch (err) {
            core.warning(`‚ö†Ô∏è Could not parse UAMI_VARS: ${err.message}`);
          }

          nunjucks.configure({ autoescape: false });

          function listFiles(dir) {
            return fs.readdirSync(dir, { withFileTypes: true })
              .flatMap(e => {
                const full = path.join(dir, e.name);
                return e.isDirectory() ? listFiles(full) : [full];
              });
          }

          for (const app of apps) {
            const srcDir = path.join('source', app.path);
            core.startGroup(`üìÇ Processing app=${app.name} path=${app.path} ‚Üí srcDir=${srcDir}`);
            dirs.push(srcDir);

            if (!fs.existsSync(srcDir)) {
              core.warning(`‚ö†Ô∏è Source dir not found for app '${app.name}' at ${srcDir}`);
              core.endGroup();
              continue;
            }

            const files = listFiles(srcDir);
            core.info(`Found ${files.length} files for app '${app.name}'`);
            files.forEach(f => core.info("  - " + f));

            for (const f of files) {
              if (/\.(ya?ml|json)$/i.test(f) && !/notemplate\.ya?ml$/i.test(f)) {
                const template = fs.readFileSync(f, 'utf8');
                const rendered = nunjucks.renderString(template, vars);
                fs.writeFileSync(f, rendered, 'utf8');

                // Detect unresolved placeholders
                if (rendered.includes("{{")) {
                  core.warning(`‚ö†Ô∏è Unresolved placeholders remain in ${f}`);
                }

                core.info(`‚úÖ Rendered ${f}`);
              } else {
                core.debug(`Skipping non-YAML/JSON file: ${f}`);
              }
            }
            core.endGroup();
          }

          return dirs.join("\n");



    - name: Copy manifests to CD repo
      id: copy
      if: ${{ inputs.delete_only == false }}
      uses: actions/github-script@v7
      env:
        CLUSTER_NAME: ${{ steps.env.outputs.cluster }}
        NAMESPACE: ${{ inputs.namespace }}
        RENDERED_DIRS: ${{ steps.render.outputs.result }}
        APPS: ${{ steps.apps.outputs.apps }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          const cluster = process.env.CLUSTER_NAME;
          const namespace = process.env.NAMESPACE;
          const renderedDirs = (process.env.RENDERED_DIRS || '').trim().split('\n').filter(Boolean);
          const apps = JSON.parse(process.env.APPS || '[]');

          // ‚úÖ Copy into the continuous-deployment repo
          const cdRoot = path.join('continuous-deployment', cluster, namespace);
          const cdRootRel = path.join(cluster, namespace);
          fs.mkdirSync(cdRoot, { recursive: true });

          // assume apps[] order matches renderedDirs[] order
          renderedDirs.forEach((dir, i) => {
            const app = apps[i];
            if (!app) return;

            const destDir = path.join(cdRoot, app.name);

            // Delete just the app‚Äôs directory first
            if (fs.existsSync(destDir)) {
              console.log(`Removing old directory for app ${app.name}: ${destDir}`);
              execSync(`rm -rf "${destDir}"`);
            }

            fs.mkdirSync(destDir, { recursive: true });
            console.log(`Copying ${dir} -> ${destDir}`);
            execSync(`cp -r "${dir}/." "${destDir}/"`, { stdio: 'inherit' });
          });

          core.setOutput('cd_path', cdRoot);
          core.setOutput('cd_path_rel', cdRootRel);

    - name: Create JSON for cluster restore
      id: create-json
      uses: actions/github-script@v7
      env:
        # use resolved cluster and namespace from earlier step
        CLUSTER: ${{ steps.env.outputs.cluster }}
        NAMESPACE: ${{ steps.env.outputs.namespace || inputs.namespace }}
        APPS: ${{ steps.apps.outputs.apps }}
        CD_REPO: ${{ inputs.cd_repo }}
        CD_REPO_ORG: ${{ inputs.cd_repo_org }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const workspace = process.env.GITHUB_WORKSPACE;
          const cluster = process.env.CLUSTER;
          const namespace = process.env.NAMESPACE || 'default';
          const apps = JSON.parse(process.env.APPS || '[]');

          if (!cluster) {
            core.setFailed("‚ùå Cluster name not resolved from environment config");
            return;
          }

          if (apps.length === 0) {
            core.warning("‚ö†Ô∏è No applications found ‚Äî skipping create.json generation");
            return;
          }

          for (const a of apps) {
            // Absolute path inside the checked-out CD repo
            const outputDir = path.join(workspace, 'continuous-deployment', cluster, namespace, a.name);
            fs.mkdirSync(outputDir, { recursive: true });

            const payload = {
              cluster,
              namespace,
              applications: [
                {
                  name: a.name,
                  repo: `https://github.com/${process.env.CD_REPO_ORG}/${process.env.CD_REPO}`,
                  overlay_dir: a.path
                }
              ]
            };

            const outputFile = path.join(outputDir, 'create.json');
            fs.writeFileSync(outputFile, JSON.stringify(payload, null, 2));
            core.info(`üßæ Wrote ${outputFile} for ${a.name} ‚Üí ${a.path}`);
          }

          core.info(`‚úÖ Finished writing create.json for ${apps.length} app(s)`);

    - name: Setup Kustomize
      if: ${{ inputs.delete_only == false }}
      uses: imranismail/setup-kustomize@v2
      with:
        kustomize-version: ${{ inputs.kustomize_version }}

    - name: Patch image tag(s) (per app)
      if: ${{ inputs.image_tag != '' && inputs.delete_only == false  }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ steps.apps.outputs.apps }}
        CD_PATH: ${{ steps.copy.outputs.cd_path }}
        IMAGE_TAG: ${{ inputs.image_tag }}
        OVERLAY_DIR: ${{ inputs.overlay_dir }}
        CONTAINER_REGISTRY: ${{ steps.env.outputs.container_registry }}
      with:
        script: |
          const { execSync } = require('child_process');
          const apps = JSON.parse(process.env.APPS || '[]');
          const overlayDir = (process.env.OVERLAY_DIR || '').trim();
          const registry = process.env.CONTAINER_REGISTRY.replace(/\/+$/, ''); // strip trailing slash if any

          for (const app of apps) {
            // Normalized layout: just app.name (+ overlays if defined)
            const base = overlayDir
              ? `${process.env.CD_PATH}/${app.name}/overlays/${overlayDir}`
              : `${process.env.CD_PATH}/${app.name}`;

            if ((app.images || []).length === 0) continue;

            for (const img of app.images) {
              // full replacement: <registry>/<image>:<tag>
              const newImage = `${registry}/${img}:${process.env.IMAGE_TAG}`;
              execSync(
                `bash -lc 'cd "${base}" && kustomize edit set image "${img}=${newImage}"'`,
                { stdio: 'inherit' }
              );
            }
          }

    - name: Replace old Traefik CRD API version
      if: ${{ inputs.delete_only == false }}
      run: |
        echo "üîé Replacing traefik.containo.us/v1alpha1 ‚Üí traefik.io/v1alpha1"
        find "${{ steps.copy.outputs.cd_path }}" -type f \( -name "*.yaml" -o -name "*.yml" \) \
          -exec sed -i 's#traefik\.containo\.us/v1alpha1#traefik.io/v1alpha1#g' {} +


    - name: Upload CD repo manifests
      if: ${{ always() && inputs.delete_only == false }}
      uses: actions/upload-artifact@v4
      with:
        name: templated-source-manifests-${{ steps.env.outputs.cluster }}-${{ fromJSON(steps.apps.outputs.apps)[0].name }}
        path: ${{ steps.copy.outputs.cd_path }}/${{ fromJSON(steps.apps.outputs.apps)[0].name }}


    - name: Debug structure
      if: ${{ inputs.debug && inputs.delete_only == false }}
      run: find "${{ steps.copy.outputs.cd_path }}" || echo "Nothing copied!"

    - name: Run kustomize build (concat per app)
      id: kustomize
      if: ${{ inputs.delete_only == false }}
      uses: actions/github-script@v7
      env:
        APPS: ${{ steps.apps.outputs.apps }}
        CD_PATH: ${{ steps.copy.outputs.cd_path }}
        OVERLAY_DIR: ${{ inputs.overlay_dir }}
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');
          const apps = JSON.parse(process.env.APPS || '[]');
          const overlayDir = (process.env.OVERLAY_DIR || '').trim();
          const outFile = `${process.env.GITHUB_WORKSPACE}/build-output.yaml`;

          fs.writeFileSync(outFile, '');
          let first = true;

          for (const app of apps) {
            const dir = overlayDir
              ? `${process.env.CD_PATH}/${app.name}/overlays/${overlayDir}`
              : `${process.env.CD_PATH}/${app.name}`;

            const yaml = execSync(`bash -lc 'cd "${dir}" && kustomize build --load-restrictor=LoadRestrictionsNone .'`, { encoding: 'utf8' });
            fs.appendFileSync(outFile, (first ? '' : '\n---\n') + yaml);
            first = false;
          }

          return outFile;


    - name: Upload built manifest as artifact
      if: ${{ always() && inputs.delete_only == false }}
      uses: actions/upload-artifact@v4
      with:
        name: built-kustomize-manifest-${{ steps.env.outputs.cluster }}-${{ fromJSON(steps.apps.outputs.apps)[0].name }}
        path: build-output.yaml


    - name: Commit and squash-merge changes
      uses: gitopsmanager/Auto-Commit-Squash-Merge@main
      with:
        token: ${{ steps.generate_token.outputs.token }}
        repo_owner: ${{ inputs.cd_repo_org }}
        repo_name: ${{ inputs.cd_repo }}
        namespace: ${{ inputs.namespace }}
        cluster: ${{ steps.env.outputs.cluster }}
        app_name: ${{ fromJSON(steps.apps.outputs.apps)[0].name }}
        repo_path_rel: ${{ steps.copy.outputs.cd_path_rel }}
        delete_only: ${{ inputs.delete_only }}


 
    - name: Construct ArgoCD URL
      id: build_argo_url
      run: |
        echo "url=https://${{ steps.env.outputs.cluster }}-argocd-argocd-web-ui.${{ steps.env.outputs.dns_zone }}" >> $GITHUB_OUTPUT

    - name: Manage ArgoCD Applications
      uses: gitopsmanager/ArgoCD-Manage-Applications@main
      with:
        argocd_url: ${{ steps.build_argo_url.outputs.url }}
        argocd_auth_token: ${{ inputs.argocd_auth_token }}
        argocd_username:  ${{ secrets.ARGOCD_USERNAME }}
        argocd_password: ${{ secrets.ARGOCD_PASSWORD }}
        insecure_argo: ${{ inputs.insecure_argo }}
        argocd_ca_cert: ${{ secrets.ARGOCD_CA_CERT }}
        namespace: ${{ inputs.namespace }}
        cd_repo: ${{ inputs.cd_repo }}
        cd_repo_org: ${{ inputs.cd_repo_org }}
        overlay_dir: ${{ inputs.overlay_dir }}
        apps: ${{ steps.apps.outputs.apps }}
        delete_first: ${{ inputs.delete_first }}
        delete_only: ${{ inputs.delete_only }}
        skip_status_check: ${{ inputs.skip_status_check }}
        no_fail: false




